//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/marcussmith/temp/jsoup/src/main/java/org/jsoup/parser/TokenQueue.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgJsoupParserTokenQueue")
#ifdef RESTRICT_OrgJsoupParserTokenQueue
#define INCLUDE_ALL_OrgJsoupParserTokenQueue 0
#else
#define INCLUDE_ALL_OrgJsoupParserTokenQueue 1
#endif
#undef RESTRICT_OrgJsoupParserTokenQueue

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (OrgJsoupParserTokenQueue_) && (INCLUDE_ALL_OrgJsoupParserTokenQueue || defined(INCLUDE_OrgJsoupParserTokenQueue))
#define OrgJsoupParserTokenQueue_

@class IOSCharArray;
@class IOSObjectArray;
@class JavaLangCharacter;

/*!
 @brief A character queue with parsing helpers.
 @author Jonathan Hedley
 */
@interface OrgJsoupParserTokenQueue : NSObject

#pragma mark Public

/*!
 @brief Create a new TokenQueue.
 @param data string of data to back queue.
 */
- (instancetype __nonnull)initWithNSString:(NSString *)data;

/*!
 @brief Add a character to the start of the queue (will be the next character retrieved).
 @param c character to add
 */
- (void)addFirstWithJavaLangCharacter:(JavaLangCharacter *)c;

/*!
 @brief Add a string to the start of the queue.
 @param seq string to add.
 */
- (void)addFirstWithNSString:(NSString *)seq;

/*!
 @brief Drops the next character off the queue.
 */
- (void)advance;

/*!
 @brief Pulls a balanced string off the queue.E.g. if queue is "(one (two) three) four", (,) will return "one (two) three",
  and leave " four" on the queue.
 Unbalanced openers and closers can be escaped (with \). Those escapes will be left
  in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for
  contains text strings; use unescape for that.
 @param open opener
 @param close closer
 @return data matched from the queue
 */
- (NSString *)chompBalancedWithChar:(jchar)open
                           withChar:(jchar)close;

/*!
 @brief Pulls a string off the queue (like consumeTo), and then pulls off the matched string (but does not return it).
 <p>
  If the queue runs out of characters before finding the seq, will return as much as it can (and queue will go
  isEmpty() == true).
 @param seq String to match up to, and not include in return, and to pull off queue.  <b> Case sensitive. </b>
 @return Data matched from queue.
 */
- (NSString *)chompToWithNSString:(NSString *)seq;

- (NSString *)chompToIgnoreCaseWithNSString:(NSString *)seq;

/*!
 @brief Consume one character off queue.
 @return first character on queue.
 */
- (jchar)consume;

/*!
 @brief Consumes the supplied sequence of the queue.If the queue does not start with the supplied sequence, will
  throw an illegal state exception -- but you should be running match() against that condition.
 <p>
      Case insensitive.
 @param seq sequence to remove from head of queue.
 */
- (void)consumeWithNSString:(NSString *)seq;

/*!
 @brief Consume an attribute key off the queue (letter, digit, -, _, :")
 @return attribute key
 */
- (NSString *)consumeAttributeKey;

/*!
 @brief Consume a CSS identifier (ID or class) off the queue (letter, digit, -, _)
      http://www.w3.org/TR/CSS2/syndata.html#value-def-identifier
 @return identifier
 */
- (NSString *)consumeCssIdentifier;

/*!
 @brief Consume a CSS element selector (tag name, but | instead of : for namespaces, to not conflict with :pseudo selects).
 @return tag name
 */
- (NSString *)consumeElementSelector;

/*!
 @brief Consume an tag name off the queue (word or :, _, -)
 @return tag name
 */
- (NSString *)consumeTagName;

/*!
 @brief Pulls a string off the queue, up to but exclusive of the match sequence, or to the queue running out.
 @param seq String to end on (and not include in return, but leave on queue).  <b> Case sensitive. </b>
 @return The matched data consumed from queue.
 */
- (NSString *)consumeToWithNSString:(NSString *)seq;

/*!
 @brief Consumes to the first sequence provided, or to the end of the queue.Leaves the terminator on the queue.
 @param seq any number of terminators to consume to.  <b> Case insensitive. </b>
 @return consumed string
 */
- (NSString *)consumeToAnyWithNSStringArray:(IOSObjectArray *)seq;

- (NSString *)consumeToIgnoreCaseWithNSString:(NSString *)seq;

/*!
 @brief Pulls the next run of whitespace characters of the queue.
 @return Whether consuming whitespace or not
 */
- (jboolean)consumeWhitespace;

/*!
 @brief Retrieves the next run of word type (letter or digit) off the queue.
 @return String of word characters from queue, or empty string if none.
 */
- (NSString *)consumeWord;

/*!
 @brief Is the queue empty?
 @return true if no data left in queue.
 */
- (jboolean)isEmpty;

/*!
 @brief Tests if the queue matches the sequence (as with match), and if they do, removes the matched string from the
  queue.
 @param seq String to search for, and if found, remove from queue.
 @return true if found and removed, false if not found.
 */
- (jboolean)matchChompWithNSString:(NSString *)seq;

/*!
 @brief Tests if the next characters on the queue match the sequence.Case insensitive.
 @param seq String to check queue for.
 @return true if the next characters match.
 */
- (jboolean)matchesWithNSString:(NSString *)seq;

- (jboolean)matchesAnyWithCharArray:(IOSCharArray *)seq;

/*!
 @brief Tests if the next characters match any of the sequences.Case insensitive.
 @param seq list of strings to case insensitively check for
 @return true of any matched, false if none did
 */
- (jboolean)matchesAnyWithNSStringArray:(IOSObjectArray *)seq;

/*!
 @brief Case sensitive match test.
 @param seq string to case sensitively check for
 @return true if matched, false if not
 */
- (jboolean)matchesCSWithNSString:(NSString *)seq;

- (jboolean)matchesStartTag;

/*!
 @brief Tests if queue starts with a whitespace character.
 @return if starts with whitespace
 */
- (jboolean)matchesWhitespace;

/*!
 @brief Test if the queue matches a word character (letter or digit).
 @return if matches a word character
 */
- (jboolean)matchesWord;

/*!
 @brief Retrieves but does not remove the first character from the queue.
 @return First character, or 0 if empty.
 */
- (jchar)peek;

/*!
 @brief Consume and return whatever is left on the queue.
 @return remained of queue.
 */
- (NSString *)remainder;

- (NSString *)description;

/*!
 @brief Unescaped a \ escaped string.
 @param inArg backslash escaped string
 @return unescaped string
 */
+ (NSString *)unescapeWithNSString:(NSString *)inArg;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgJsoupParserTokenQueue)

FOUNDATION_EXPORT void OrgJsoupParserTokenQueue_initWithNSString_(OrgJsoupParserTokenQueue *self, NSString *data);

FOUNDATION_EXPORT OrgJsoupParserTokenQueue *new_OrgJsoupParserTokenQueue_initWithNSString_(NSString *data) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgJsoupParserTokenQueue *create_OrgJsoupParserTokenQueue_initWithNSString_(NSString *data);

FOUNDATION_EXPORT NSString *OrgJsoupParserTokenQueue_unescapeWithNSString_(NSString *inArg);

J2OBJC_TYPE_LITERAL_HEADER(OrgJsoupParserTokenQueue)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_OrgJsoupParserTokenQueue")
